{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "d06dc770-1c2b-4ddb-9280-ef4f0cedf5af",
   "metadata": {},
   "source": [
    "# from flask import Flask,request,render_template\n",
    "import numpy as np\n",
    "import pandas\n",
    "import sklearn\n",
    "import pickle\n",
    "\n",
    "# importing model\n",
    "model = pickle.load(open('D:\\\\AI based crop Project files\\minmaxscaler.pkl','rb'))\n",
    "sc = pickle.load(open('standscaler.pkl','rb'))\n",
    "ms = pickle.load(open('minmaxscaler.pkl','rb'))\n",
    "\n",
    "# creating flask app\n",
    "app = Flask(__name__)\n",
    "\n",
    "@app.route('/')\n",
    "def index():\n",
    "    return render_template(\"AIbasedcrop.html\")\n",
    "\n",
    "@app.route(\"/predict\",methods=['POST'])\n",
    "def predict():\n",
    "    N = request.form['Nitrogen']\n",
    "    P = request.form['Phosporus']\n",
    "    K = request.form['Potassium']\n",
    "    temp = request.form['Temperature']\n",
    "    humidity = request.form['Humidity']\n",
    "    ph = request.form['Ph']\n",
    "    rainfall = request.form['Rainfall']\n",
    "\n",
    "    feature_list = [N, P, K, temp, humidity, ph, rainfall]\n",
    "    single_pred = np.array(feature_list).reshape(1, -1)\n",
    "\n",
    "    scaled_features = ms.transform(single_pred)\n",
    "    final_features = sc.transform(scaled_features)\n",
    "    prediction = model.predict(final_features)\n",
    "\n",
    "    crop_dict = {1: \"Rice\", 2: \"Maize\", 3: \"Jute\", 4: \"Cotton\", 5: \"Coconut\", 6: \"Papaya\", 7: \"Orange\",\n",
    "                 8: \"Apple\", 9: \"Muskmelon\", 10: \"Watermelon\", 11: \"Grapes\", 12: \"Mango\", 13: \"Banana\",\n",
    "                 14: \"Pomegranate\", 15: \"Lentil\", 16: \"Blackgram\", 17: \"Mungbean\", 18: \"Mothbeans\",\n",
    "                 19: \"Pigeonpeas\", 20: \"Kidneybeans\", 21: \"Chickpea\", 22: \"Coffee\"}\n",
    "\n",
    "    if prediction[0] in crop_dict:\n",
    "        crop = crop_dict[prediction[0]]\n",
    "        result = \"{} is the best crop to be cultivated right there\".format(crop)\n",
    "    else:\n",
    "        result = \"Sorry, we could not determine the best crop to be cultivated with the provided data.\"\n",
    "    return render_template('index.html',result = result)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# python main\n",
    "if __name__ == \"__main__\":\n",
    "    app.run(debug=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "74dca6f0-ccce-47fc-8360-78c73a228108",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'MODEL_DIR' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[11]\u001b[39m\u001b[32m, line 10\u001b[39m\n\u001b[32m      5\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01msys\u001b[39;00m\n\u001b[32m      6\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtraceback\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m10\u001b[39m MODEL_PATH = os.path.join(\u001b[43mMODEL_DIR\u001b[49m, \u001b[33m\"\u001b[39m\u001b[33mmodel.pkl\u001b[39m\u001b[33m\"\u001b[39m)\n\u001b[32m     11\u001b[39m STAND_SCALER_PATH = os.path.join(MODEL_DIR, \u001b[33m\"\u001b[39m\u001b[33mstandscaler.pkl\u001b[39m\u001b[33m\"\u001b[39m)\n\u001b[32m     12\u001b[39m MINMAX_SCALER_PATH = os.path.join(MODEL_DIR, \u001b[33m\"\u001b[39m\u001b[33mminmaxscaler.pkl\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[31mNameError\u001b[39m: name 'MODEL_DIR' is not defined"
     ]
    }
   ],
   "source": [
    "from flask import Flask, request, render_template\n",
    "import numpy as np\n",
    "import os\n",
    "import pickle\n",
    "import sys\n",
    "import traceback\n",
    "\n",
    "\n",
    "\n",
    "MODEL_PATH = os.path.join(MODEL_DIR, \"model.pkl\")\n",
    "STAND_SCALER_PATH = os.path.join(MODEL_DIR, \"standscaler.pkl\")\n",
    "MINMAX_SCALER_PATH = os.path.join(MODEL_DIR, \"minmaxscaler.pkl\")\n",
    "\n",
    "# helper to load a pickle and provide clearer error messages\n",
    "def load_pickle(path):\n",
    "    if not os.path.exists(path):\n",
    "        raise FileNotFoundError(f\"Required file not found: {path}\")\n",
    "    try:\n",
    "        with open(path, 'rb') as f:\n",
    "            return pickle.load(f)\n",
    "    except Exception as e:\n",
    "        # raise a new exception with context so the import-time error is clear\n",
    "        raise RuntimeError(f\"Failed to load pickle at {path}: {e}\")\n",
    "\n",
    "# load model & scalers (fail loudly with clear message)\n",
    "try:\n",
    "    model = load_pickle('D:\\\\AI based crop Project files\\\\minmaxscaler.pkl','rb')\n",
    "    sc = load_pickle( 'D:\\\\AI based crop Project files\\\\standscaler.pkl','rb')\n",
    "    ms = load_pickle('D:\\\\AI based crop Project files\\\\minmaxscaler.pkl','rb')\n",
    "except Exception as e:\n",
    "    # Print full traceback and exit with non-zero so reloader shows SystemExit (but we include full info)\n",
    "    print(\"ERROR while loading model/scalers:\", file=sys.stderr)\n",
    "    traceback.print_exc()\n",
    "    # Re-raise so Flask (or direct run) can show what's wrong\n",
    "    raise\n",
    "\n",
    "app = Flask(__name__)\n",
    "\n",
    "@app.route('/')\n",
    "def index():\n",
    "    # Make sure the templates/ folder contains AIbasedcrop.html\n",
    "    return render_template(\"AIbasedcrop.html\")\n",
    "\n",
    "@app.route('/predict', methods=['POST'])\n",
    "def predict():\n",
    "    names = ['Nitrogen', 'Phosporus', 'Potassium', 'Temperature', 'Humidity', 'Ph', 'Rainfall']\n",
    "    try:\n",
    "        values = []\n",
    "        for n in names:\n",
    "            if n not in request.form:\n",
    "                raise ValueError(f\"Missing form field: {n}\")\n",
    "            raw = request.form.get(n).strip()\n",
    "            if raw == '':\n",
    "                raise ValueError(f\"Empty value for {n}\")\n",
    "            values.append(float(raw))\n",
    "\n",
    "        single_pred = np.array(values).reshape(1, -1)\n",
    "\n",
    "        # Apply the same scaling sequence as used in training\n",
    "        scaled_features = ms.transform(single_pred)\n",
    "        final_features = sc.transform(scaled_features)\n",
    "\n",
    "        prediction = model.predict(final_features)\n",
    "\n",
    "        # Normalize prediction to an int or string\n",
    "        pred_val = prediction[0]\n",
    "        try:\n",
    "            pred_key = int(pred_val)\n",
    "        except Exception:\n",
    "            pred_key = pred_val\n",
    "\n",
    "        crop_dict = {\n",
    "            1: \"Rice\", 2: \"Maize\", 3: \"Jute\", 4: \"Cotton\", 5: \"Coconut\", 6: \"Papaya\", 7: \"Orange\",\n",
    "            8: \"Apple\", 9: \"Muskmelon\", 10: \"Watermelon\", 11: \"Grapes\", 12: \"Mango\", 13: \"Banana\",\n",
    "            14: \"Pomegranate\", 15: \"Lentil\", 16: \"Blackgram\", 17: \"Mungbean\", 18: \"Mothbeans\",\n",
    "            19: \"Pigeonpeas\", 20: \"Kidneybeans\", 21: \"Chickpea\", 22: \"Coffee\"\n",
    "        }\n",
    "\n",
    "        if isinstance(pred_key, int) and pred_key in crop_dict:\n",
    "            crop = crop_dict[pred_key]\n",
    "            result = f\"{crop} is the best crop to be cultivated with the provided inputs.\"\n",
    "        elif isinstance(pred_key, str):\n",
    "            result = f\"{pred_key} is the best crop to be cultivated with the provided inputs.\"\n",
    "        else:\n",
    "            result = \"Sorry, we could not determine the best crop with the provided data.\"\n",
    "\n",
    "    except ValueError as ve:\n",
    "        result = f\"Input error: {ve}\"\n",
    "    except Exception as e:\n",
    "        # include exception in result for dev debugging (do not expose in production)\n",
    "        result = f\"Prediction error: {e}\"\n",
    "\n",
    "    return render_template(\"AIbasedcrop.html\", result=result)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # For debugging: set use_reloader=False to see import-time exceptions in a single process\n",
    "    # But once fixed, you can remove use_reloader=False so watchdog will reload on changes.\n",
    "    app.run(debug=True, use_reloader=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f6345e7b-bdb6-4e8f-a4b0-16c8fa428006",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
